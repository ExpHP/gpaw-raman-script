
from collections import namedtuple
from script import symmetry, test_utils
import script
import numpy as np
import pytest


Symmetry = namedtuple('Symmetry', ['oper_cart_rots', 'oper_perms', 'quotient_perms'])
DispData = namedtuple('DispData', ['atom', 'cart', 'data'])


def compose_perm(a, b): return b[a]
def compose_rot(a, b): return a @ b
def make_rot_hashable(a): return tuple(map(tuple, a.tolist()))
def make_perm_hashable(a): return tuple(a.tolist())


def grouptree_rotation_xyz():
    """ SemigroupTree of rotation matrices generated by the matrix that permutes the vector (x,y,z) into (y,z,x). """
    return test_utils.SemigroupTree(
        [np.array([[0,0,1],[1,0,0],[0,1,0]])],
        compose_rot, make_rot_hashable,
    )


# Spacegroup: C3 that permutes the cartesian axes as x->y->z->x
#  Structure: a single atom
def sym_xyz_1_atom():
    grouptree = grouptree_rotation_xyz()
    oper_cart_rots = grouptree.members
    oper_perms = np.array([[0]] * len(oper_cart_rots))
    quotient_perms = None
    return Symmetry(oper_cart_rots=oper_cart_rots, oper_perms=oper_perms, quotient_perms=quotient_perms)


# Spacegroup: C3 that permutes the cartesian axes as x->y->z->x
#  Structure: atoms at (1, 0, 0), (0, 1, 0), (0, 0, 1)
def sym_xyz_3_atom():
    grouptree = grouptree_rotation_xyz()
    oper_cart_rots = grouptree.members

    generators = [np.array([2, 0, 1])]  # generator that corresponds to the grouptree's generator
    oper_perms = grouptree.compute_homomorphism(
        get_generator = lambda gen_i, _rot: generators[gen_i],
        compose = compose_perm,
    )
    quotient_perms = None
    return Symmetry(oper_cart_rots=oper_cart_rots, oper_perms=oper_perms, quotient_perms=quotient_perms)


# Spacegroup: 1
#  Structure: atoms 0, 2, and 4 are related by translation.  atoms 1, 3, and 5 are related by translation.
def sym_quotient_translational_010101():
    quotient_perms = test_utils.SemigroupTree(
        [np.array([2,3,4,5,0,1])],
        compose_perm, make_perm_hashable,
    ).members
    oper_cart_rots = [np.eye(3)]
    oper_perms = [np.arange(len(quotient_perms[0]))]  # identity
    return Symmetry(oper_cart_rots=oper_cart_rots, oper_perms=oper_perms, quotient_perms=quotient_perms)


# Like sym_quotient_translational, but the translational symmetry is embedded in the spacegroup instead
def sym_embedded_translational_010101():
    _oper_cart_rots, oper_perms, quotient_perms = sym_quotient_translational_010101()

    # since there's no rotations, just move the quotient perms into the oper perms to embed the translational symmetry
    oper_cart_rots = [np.eye(3)] * len(quotient_perms)
    oper_perms = quotient_perms
    quotient_perms = None
    return Symmetry(oper_cart_rots=oper_cart_rots, oper_perms=oper_perms, quotient_perms=quotient_perms)


# Spacegroup: C3 that permutes the cartesian axes as x->y->z->x
#  Structure: atoms 0, 1 are related by translation, but all rotations map them to themselves
def sym_quotient_translational_00_xyz():
    oper_cart_rots = grouptree_rotation_xyz().members
    quotient_perms = np.array([[0, 1, 2], [1, 2, 0], [2, 0, 1]])
    oper_perms = [np.arange(len(quotient_perms[0]))] * len(oper_cart_rots)
    return Symmetry(oper_cart_rots=oper_cart_rots, oper_perms=oper_perms, quotient_perms=quotient_perms)


# * Tests a GeneralArrayCallbacks 'cart' axis
def test_general_array_vec():
    sym = sym_xyz_1_atom()
    callbacks = symmetry.GeneralArrayCallbacks(['cart'], oper_deperms=sym.oper_perms)
    disp_atoms, disp_carts, disp_values = zip(*[
        DispData(0, [ 0.1, 0, 0], data=np.array([ 1., 0, 0])),
        DispData(0, [-0.1, 0, 0], data=np.array([-1., 0, 0])),
    ])
    derivs = symmetry.expand_derivs_by_symmetry(
            callbacks=callbacks, disp_atoms=disp_atoms, disp_carts=disp_carts, disp_values=disp_values,
            oper_cart_rots=sym.oper_cart_rots, oper_perms=sym.oper_perms, quotient_perms=sym.quotient_perms,
    )
    derivs = np.array(derivs.tolist())
    assert np.allclose(derivs, np.array([[
        [10, 0, 0],
        [0, 10, 0],
        [0, 0, 10],
    ]]))


# * Tests rotation of outer axis of gradient when applying symmetry.
# * Tests a GeneralArrayCallbacks 'atom' axis.
def test_general_array_atom():
    sym = sym_xyz_3_atom()
    callbacks = symmetry.GeneralArrayCallbacks(['atom'], oper_deperms=sym.oper_perms)
    disp_atoms, disp_carts, disp_values = zip(*[
        # because the operator is no longer in the site symmetry, we need more disps
        DispData(0, [ 0.1,    0,    0], data=np.array([ 2.,  3.,  4.])),
        DispData(0, [-0.1,    0,    0], data=np.array([-2., -3., -4.])),
        DispData(0, [   0,  0.1,    0], data=np.array([ 5.,  6.,  7.])),
        DispData(0, [   0, -0.1,    0], data=np.array([-5., -6., -7.])),
        DispData(0, [   0,    0,  0.1], data=np.array([ 8.,  9.,  10.])),
        DispData(0, [   0,    0, -0.1], data=np.array([-8., -9., -10.])),
    ])
    print(sym.oper_perms)
    derivs = symmetry.expand_derivs_by_symmetry(
            callbacks=callbacks, disp_atoms=disp_atoms, disp_carts=disp_carts, disp_values=disp_values,
            oper_cart_rots=sym.oper_cart_rots, oper_perms=sym.oper_perms, quotient_perms=sym.quotient_perms,
    )
    derivs = np.array(derivs.tolist())
    assert np.allclose(derivs, np.array([[
        [20, 30,  40],  # deriv w.r.t. atom 0 x
        [50, 60,  70],  # deriv w.r.t. atom 0 y
        [80, 90, 100],  # deriv w.r.t. atom 0 z
    ], [
        [100, 80, 90],  # deriv w.r.t. atom 1 x
        [ 40, 20, 30],  # deriv w.r.t. atom 1 y
        [ 70, 50, 60],  # deriv w.r.t. atom 1 z
    ], [
        [60,  70, 50],  # deriv w.r.t. atom 2 x
        [90, 100, 80],  # deriv w.r.t. atom 2 y
        [30,  40, 20],  # deriv w.r.t. atom 2 z
    ]]))


def test_pure_translation():
    for (description, sym) in [
            ('SEPARATE TRANSLATIONS', sym_quotient_translational_010101()),
            ('EMBEDDED TRANSLATIONS', sym_embedded_translational_010101()),
    ]:
        print(f'TRYING {description}')
        callbacks = symmetry.GeneralArrayCallbacks([], oper_deperms=sym.oper_perms)
        disp_atoms, disp_carts, disp_values = zip(*[
            DispData(0, [ 0.1,    0,    0], data=np.array( 1.)),
            DispData(0, [-0.1,    0,    0], data=np.array(-1.)),
            DispData(0, [   0,  0.1,    0], data=np.array( 2.)),
            DispData(0, [   0, -0.1,    0], data=np.array(-2.)),
            DispData(0, [   0,    0,  0.1], data=np.array( 3.)),
            DispData(0, [   0,    0, -0.1], data=np.array(-3.)),
            DispData(1, [ 0.1,    0,    0], data=np.array( 4.)),
            DispData(1, [-0.1,    0,    0], data=np.array(-4.)),
            DispData(1, [   0,  0.1,    0], data=np.array( 5.)),
            DispData(1, [   0, -0.1,    0], data=np.array(-5.)),
            DispData(1, [   0,    0,  0.1], data=np.array( 6.)),
            DispData(1, [   0,    0, -0.1], data=np.array(-6.)),
        ])
        derivs = symmetry.expand_derivs_by_symmetry(
                callbacks=callbacks, disp_atoms=disp_atoms, disp_carts=disp_carts, disp_values=disp_values,
                oper_cart_rots=sym.oper_cart_rots, oper_perms=sym.oper_perms, quotient_perms=sym.quotient_perms,
        )
        derivs = np.array(derivs.tolist())
        assert np.allclose(derivs, np.array([
            [10, 20, 30],  # gradient w.r.t. atom 0
            [40, 50, 60],  # gradient w.r.t. atom 1
            [10, 20, 30],  # gradient w.r.t. atom 2
            [40, 50, 60],  # gradient w.r.t. atom 3
            [10, 20, 30],  # gradient w.r.t. atom 4
            [40, 50, 60],  # gradient w.r.t. atom 5
        ]))


def test_general_array_atom_quotient():
    sym = sym_quotient_translational_00_xyz()

    callbacks = symmetry.GeneralArrayCallbacks(['atom'], oper_deperms=sym.oper_perms)
    disp_atoms, disp_carts, disp_values = zip(*[
        DispData(0, [ 0.1,    0,    0], data=np.array([ 1.,  2.,  3.])),
        DispData(0, [-0.1,    0,    0], data=np.array([-1., -2., -3.])),
    ])
    derivs = symmetry.expand_derivs_by_symmetry(
            callbacks=callbacks, disp_atoms=disp_atoms, disp_carts=disp_carts, disp_values=disp_values,
            oper_cart_rots=sym.oper_cart_rots, oper_perms=sym.oper_perms, quotient_perms=sym.quotient_perms,
    )
    derivs = np.array(derivs.tolist())
    assert np.allclose(derivs, np.array([[
        [10, 20, 30],  # derivative w.r.t. atom 0 x
        [10, 20, 30],  # derivative w.r.t. atom 0 y
        [10, 20, 30],  # derivative w.r.t. atom 0 z
    ], [
        [30, 10, 20],  # derivative w.r.t. atom 1 x
        [30, 10, 20],  # derivative w.r.t. atom 1 y
        [30, 10, 20],  # derivative w.r.t. atom 1 z
    ], [
        [20, 30, 10],  # derivative w.r.t. atom 2 x
        [20, 30, 10],  # derivative w.r.t. atom 2 y
        [20, 30, 10],  # derivative w.r.t. atom 2 z
    ]]))
