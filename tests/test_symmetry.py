
from collections import namedtuple
from script import symmetry, test_utils
import script
import numpy as np
import pytest

Symmetry = namedtuple('Symmetry', ['oper_cart_rots', 'oper_perms', 'quotient_perms'])
DispData = namedtuple('DispData', ['atom', 'cart', 'data'])

def compose_perm(a, b): return b[a]
def compose_rot(a, b): return a @ b

def grouptree_rotation_xyz():
    """ SemigroupTree of rotation matrices generated by the matrix that permutes the vector (x,y,z) into (y,z,x). """
    return test_utils.SemigroupTree(
        [np.array([[0,0,1],[1,0,0],[0,1,0]])],
        compose_rot,
        make_hashable=lambda arr: tuple(map(tuple, arr.tolist())),
    )

# Spacegroup: C3 that permutes the cartesian axes as x->y->z->x
#  Structure: a single atom
def sym_xyz_1_atom():
    """  """
    grouptree = grouptree_rotation_xyz()
    oper_cart_rots = grouptree.members
    oper_perms = np.array([[0]] * len(oper_cart_rots))
    quotient_perms = None
    return Symmetry(oper_cart_rots=oper_cart_rots, oper_perms=oper_perms, quotient_perms=quotient_perms)

# Spacegroup: C3 that permutes the cartesian axes as x->y->z->x
#  Structure: atoms at (1, 0, 0), (0, 1, 0), (0, 0, 1)
def sym_xyz_3_atom():
    """  """
    grouptree = grouptree_rotation_xyz()
    oper_cart_rots = grouptree.members

    generators = [np.array([2, 0, 1])]  # generator that corresponds to the grouptree's generator
    oper_perms = grouptree.compute_homomorphism(
        get_generator = lambda gen_i, _rot: generators[gen_i],
        compose = compose_perm,
    )
    quotient_perms = None
    return Symmetry(oper_cart_rots=oper_cart_rots, oper_perms=oper_perms, quotient_perms=quotient_perms)

def test_general_array_vec():
    sym = sym_xyz_1_atom()
    callbacks = symmetry.GeneralArrayCallbacks(['cart'], oper_deperms=sym.oper_perms)
    disp_atoms, disp_carts, disp_values = zip(*[
        DispData(0, [ 0.1, 0, 0], data=np.array([ 1., 0, 0])),
        DispData(0, [-0.1, 0, 0], data=np.array([-1., 0, 0])),
    ])
    derivs = symmetry.expand_derivs_by_symmetry(
            callbacks=callbacks, disp_atoms=disp_atoms, disp_carts=disp_carts, disp_values=disp_values,
            oper_cart_rots=sym.oper_cart_rots, oper_perms=sym.oper_perms, quotient_perms=sym.quotient_perms,
    )
    derivs = np.array(derivs.tolist())
    assert np.allclose(derivs, np.array([[
        [10, 0, 0],
        [0, 10, 0],
        [0, 0, 10],
    ]]))

def test_general_array_atom():
    sym = sym_xyz_3_atom()
    callbacks = symmetry.GeneralArrayCallbacks(['atom'], oper_deperms=sym.oper_perms)
    disp_atoms, disp_carts, disp_values = zip(*[
        # because the operator is no longer in the site symmetry, we need more disps
        DispData(0, [ 0.1,    0,    0], data=np.array([ 2.,  3.,  4.])),
        DispData(0, [-0.1,    0,    0], data=np.array([-2., -3., -4.])),
        DispData(0, [   0,  0.1,    0], data=np.array([ 5.,  6.,  7.])),
        DispData(0, [   0, -0.1,    0], data=np.array([-5., -6., -7.])),
        DispData(0, [   0,    0,  0.1], data=np.array([ 8.,  9.,  10.])),
        DispData(0, [   0,    0, -0.1], data=np.array([-8., -9., -10.])),
    ])
    print(sym.oper_perms)
    derivs = symmetry.expand_derivs_by_symmetry(
            callbacks=callbacks, disp_atoms=disp_atoms, disp_carts=disp_carts, disp_values=disp_values,
            oper_cart_rots=sym.oper_cart_rots, oper_perms=sym.oper_perms, quotient_perms=sym.quotient_perms,
    )
    derivs = np.array(derivs.tolist())
    assert np.allclose(derivs, np.array([[
        [20, 30,  40],  # deriv w.r.t. atom 0 x
        [50, 60,  70],  # deriv w.r.t. atom 0 y
        [80, 90, 100],  # deriv w.r.t. atom 0 z
    ], [
        [100, 80, 90],  # deriv w.r.t. atom 1 x
        [ 40, 20, 30],  # deriv w.r.t. atom 1 y
        [ 70, 50, 60],  # deriv w.r.t. atom 1 z
    ], [
        [60,  70, 50],  # deriv w.r.t. atom 2 x
        [90, 100, 80],  # deriv w.r.t. atom 2 y
        [30,  40, 20],  # deriv w.r.t. atom 2 z
    ]]))



